title,slug,difficulty,category_name,tags,companies,statement,constraints,hints,approach,time_complexity,space_complexity,leetcode_url,hackerrank_url,external_url,time_limit,memory_limit,is_premium,is_private,status
"Two Sum","two-sum","EASY","Array","Array, Hash Table","Google, Amazon, Facebook","Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:
Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:
Input: nums = [3,3], target = 6
Output: [0,1]","• 2 ≤ nums.length ≤ 10^4
• -10^9 ≤ nums[i] ≤ 10^9
• -10^9 ≤ target ≤ 10^9
• Only one valid answer exists.","[""Use a hash map to store the difference between target and current number"", ""Think about what you need to find for each number""]","Use a hash map to store numbers you've seen and their indices. For each number, check if target - current number exists in the hash map.","O(n)","O(n)","https://leetcode.com/problems/two-sum/","","",5,256,FALSE,FALSE,PUBLISHED
"Best Time to Buy and Sell Stock","best-time-to-buy-and-sell-stock","EASY","Array","Array, Dynamic Programming","Google, Amazon, Microsoft","You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.

Example 2:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.","• 1 ≤ prices.length ≤ 10^5
• 0 ≤ prices[i] ≤ 10^4","[""Keep track of the minimum price seen so far"", ""Calculate profit at each step""]","Track the minimum price seen so far and calculate the maximum profit at each step.","O(n)","O(1)","https://leetcode.com/problems/best-time-to-buy-and-sell-stock/","","",5,256,FALSE,FALSE,PUBLISHED
"Valid Parentheses","valid-parentheses","EASY","Stack","String, Stack","Google, Amazon, Microsoft","Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

Example 1:
Input: s = ""()""
Output: true

Example 2:
Input: s = ""()[]{}""
Output: true

Example 3:
Input: s = ""(]""
Output: false","• 1 ≤ s.length ≤ 10^4
• s consists of parentheses only '()[]{}'.","[""Use a stack data structure"", ""Match opening brackets with closing brackets""]","Use a stack to keep track of opening brackets. For each closing bracket, check if it matches the most recent opening bracket.","O(n)","O(n)","https://leetcode.com/problems/valid-parentheses/","","",5,256,FALSE,FALSE,PUBLISHED
"Merge Two Sorted Lists","merge-two-sorted-lists","EASY","Linked List","Linked List, Recursion","Google, Amazon, Microsoft","You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists in a sorted manner and return the head of the merged linked list.

The list should be made by splicing together the nodes of the first two lists.

Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]

Example 2:
Input: list1 = [], list2 = []
Output: []

Example 3:
Input: list1 = [], list2 = [0]
Output: [0]","• The number of nodes in both lists is in the range [0, 50].
• -100 ≤ Node.val ≤ 100
• Both list1 and list2 are sorted in non-decreasing order.","[""Use a dummy head node to simplify the logic"", ""Compare values at current positions""]","Create a dummy head node and iterate through both lists, always choosing the smaller current value.","O(n + m)","O(1)","https://leetcode.com/problems/merge-two-sorted-lists/","","",5,256,FALSE,FALSE,PUBLISHED
"Maximum Subarray","maximum-subarray","MEDIUM","Dynamic Programming","Array, Dynamic Programming, Divide and Conquer","Google, Amazon, Microsoft","Given an integer array nums, find the subarray with the largest sum, and return its sum.

Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.

Example 3:
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.","• 1 ≤ nums.length ≤ 10^5
• -10^4 ≤ nums[i] ≤ 10^4","[""Think about Kadane's algorithm"", ""At each position, decide whether to extend the current subarray or start a new one""]","Use Kadane's algorithm: at each position, choose between extending the current subarray or starting fresh.","O(n)","O(1)","https://leetcode.com/problems/maximum-subarray/","","",5,256,FALSE,FALSE,PUBLISHED
"Climbing Stairs","climbing-stairs","EASY","Dynamic Programming","Math, Dynamic Programming, Memoization","Google, Amazon","You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step","• 1 ≤ n ≤ 45","[""This is a Fibonacci sequence problem"", ""Think about how many ways to reach step i from step i-1 and i-2""]","This follows Fibonacci sequence pattern: ways(n) = ways(n-1) + ways(n-2)","O(n)","O(1)","https://leetcode.com/problems/climbing-stairs/","","",5,256,FALSE,FALSE,PUBLISHED
"Binary Tree Inorder Traversal","binary-tree-inorder-traversal","EASY","Tree","Stack, Tree, Depth-First Search, Binary Tree","Google, Amazon, Microsoft","Given the root of a binary tree, return the inorder traversal of its nodes' values.

Example 1:
Input: root = [1,null,2,3]
Output: [1,3,2]

Example 2:
Input: root = []
Output: []

Example 3:
Input: root = [1]
Output: [1]","• The number of nodes in the tree is in the range [0, 100].
• -100 ≤ Node.val ≤ 100","[""Use recursion or stack-based iteration"", ""Inorder: left, root, right""]","Recursively traverse left subtree, visit root, then traverse right subtree.","O(n)","O(n)","https://leetcode.com/problems/binary-tree-inorder-traversal/","","",5,256,FALSE,FALSE,PUBLISHED
"Same Tree","same-tree","EASY","Tree","Tree, Depth-First Search, Breadth-First Search, Binary Tree","Google, Amazon","Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

Example 1:
Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:
Input: p = [1,2], q = [1,null,2]
Output: false

Example 3:
Input: p = [1,2,1], q = [1,1,2]
Output: false","• The number of nodes in both trees is in the range [0, 100].
• -10^4 ≤ Node.val ≤ 10^4","[""Use recursive approach"", ""Check both structure and values""]","Recursively compare nodes: both null, one null, or values and subtrees match.","O(n)","O(n)","https://leetcode.com/problems/same-tree/","","",5,256,FALSE,FALSE,PUBLISHED
"Symmetric Tree","symmetric-tree","EASY","Tree","Tree, Depth-First Search, Breadth-First Search, Binary Tree","Google, Microsoft","Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

Example 1:
Input: root = [1,2,2,3,4,4,3]
Output: true

Example 2:
Input: root = [1,2,2,null,3,null,3]
Output: false","• The number of nodes in the tree is in the range [1, 1000].
• -100 ≤ Node.val ≤ 100","[""Compare left and right subtrees"", ""Use recursive helper function""]","Use a helper function to check if left and right subtrees are mirrors of each other.","O(n)","O(n)","https://leetcode.com/problems/symmetric-tree/","","",5,256,FALSE,FALSE,PUBLISHED
"Maximum Depth of Binary Tree","maximum-depth-of-binary-tree","EASY","Tree","Tree, Depth-First Search, Breadth-First Search, Binary Tree","Google, Amazon","Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 3

Example 2:
Input: root = [1,null,2]
Output: 2","• The number of nodes in the tree is in the range [0, 10^4].
• -100 ≤ Node.val ≤ 100","[""Use recursion"", ""Maximum depth is 1 + max depth of subtrees""]","Recursively find the maximum depth of left and right subtrees, add 1.","O(n)","O(n)","https://leetcode.com/problems/maximum-depth-of-binary-tree/","","",5,256,FALSE,FALSE,PUBLISHED
"Valid Palindrome","valid-palindrome","EASY","Two Pointers","Two Pointers, String","Google, Amazon, Microsoft","A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.

Given a string s, return true if it is a palindrome, or false otherwise.

Example 1:
Input: s = ""A man, a plan, a canal: Panama""
Output: true
Explanation: ""amanaplanacanalpanama"" is a palindrome.

Example 2:
Input: s = ""race a car""
Output: false
Explanation: ""raceacar"" is not a palindrome.","• 1 ≤ s.length ≤ 2 * 10^5
• s consists only of printable ASCII characters.","[""Use two pointers from both ends"", ""Skip non-alphanumeric characters""]","Use two pointers, skip non-alphanumeric characters, compare characters.","O(n)","O(1)","https://leetcode.com/problems/valid-palindrome/","","",5,256,FALSE,FALSE,PUBLISHED
"Single Number","single-number","EASY","Bit Manipulation","Array, Bit Manipulation","Google, Amazon","Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

Example 1:
Input: nums = [2,2,1]
Output: 1

Example 2:
Input: nums = [4,1,2,1,2]
Output: 4

Example 3:
Input: nums = [1]
Output: 1","• 1 ≤ nums.length ≤ 3 * 10^4
• -3 * 10^4 ≤ nums[i] ≤ 3 * 10^4
• Each element in the array appears twice except for one element which appears only once.","[""Use XOR operation"", ""XOR of two same numbers is 0""]","Use XOR operation: a ⊕ a = 0, so XORing all numbers will leave only the single number.","O(n)","O(1)","https://leetcode.com/problems/single-number/","","",5,256,FALSE,FALSE,PUBLISHED
"Linked List Cycle","linked-list-cycle","EASY","Linked List","Hash Table, Linked List, Two Pointers","Google, Amazon, Microsoft","Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.

Return true if there is a cycle in the linked list. Otherwise, return false.

Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

Example 2:
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.","• The number of the nodes in the list is in the range [0, 10^4].
• -10^5 ≤ Node.val ≤ 10^5
• pos is -1 or a valid index in the linked-list.","[""Use Floyd's cycle-finding algorithm (tortoise and hare)"", ""Two pointers with different speeds""]","Use two pointers: slow moves one step, fast moves two steps. If there's a cycle, they will meet.","O(n)","O(1)","https://leetcode.com/problems/linked-list-cycle/","","",5,256,FALSE,FALSE,PUBLISHED
"Min Stack","min-stack","EASY","Stack","Stack, Design","Google, Amazon","Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the MinStack class:
• MinStack() initializes the stack object.
• void push(int val) pushes the element val onto the stack.
• void pop() removes the element on the top of the stack.
• int top() gets the top element of the stack.
• int getMin() retrieves the minimum element in the stack.

You must implement a solution with O(1) time complexity for each function.","• -2^31 ≤ val ≤ 2^31 - 1
• Methods pop, top and getMin operations will always be called on non-empty stacks.
• At most 3 * 10^4 calls will be made to push, pop, top, and getMin.","[""Use two stacks: one for values, one for minimums"", ""Keep track of minimum at each level""]","Use two stacks: main stack for values and auxiliary stack to keep track of minimums.","O(1)","O(n)","https://leetcode.com/problems/min-stack/","","",5,256,FALSE,FALSE,PUBLISHED
"Intersection of Two Linked Lists","intersection-of-two-linked-lists","EASY","Linked List","Hash Table, Linked List, Two Pointers","Google, Amazon, Microsoft","Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.

Example 1:
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'

Example 2:
Input: intersectVal = 0, listA = [2,6,4], listB = [1,5]
Output: No intersection","• The number of nodes of listA is in the m.
• The number of nodes of listB is in the n.
• 1 ≤ m, n ≤ 3 * 10^4
• 1 ≤ Node.val ≤ 10^5","[""Use two pointers with different starting points"", ""When one pointer reaches end, start from other list's head""]","Use two pointers: when one reaches the end, redirect to the other list's head. They'll meet at intersection or null.","O(m + n)","O(1)","https://leetcode.com/problems/intersection-of-two-linked-lists/","","",5,256,FALSE,FALSE,PUBLISHED